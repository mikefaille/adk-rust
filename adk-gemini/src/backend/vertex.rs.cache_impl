    async fn create_cached_content(&self, req: CreateCachedContentRequest) -> Result<CachedContent, Error> {
        let request_value = serde_json::to_value(&req).context(GoogleCloudRequestSerializeSnafu)?;
        let mut request: google_cloud_aiplatform_v1::model::CreateCachedContentRequest =
            serde_json::from_value(request_value).context(GoogleCloudRequestDeserializeSnafu)?;

        // Set parent if not present?
        // request.parent = format!("projects/{}/locations/{}", self.project, self.location);
        // But  fields might be private.
        // If I deserialize, I hope  is optional or I can set it via builder if I construct it manually.
        // But I deserialized it.
        // If  (domain model) doesn't have parent,  (gcloud model) won't either.
        // I might need to set it.
        // Does  have public field ?
        // Usually yes for proto structs.
        request.parent = format!("projects/{}/locations/{}", self.project, self.location);

        let response = self.cache.create_cached_content(request, None).await.map_err(|source| Error::GoogleCloudRequest { source })?;

        let response_value = serde_json::to_value(&response).context(GoogleCloudResponseSerializeSnafu)?;
        serde_json::from_value(response_value).context(GoogleCloudResponseDeserializeSnafu)
    }

    async fn get_cached_content(&self, name: &str) -> Result<CachedContent, Error> {
         let request = google_cloud_aiplatform_v1::model::GetCachedContentRequest {
             name: name.to_string(),
         };
         let response = self.cache.get_cached_content(request, None).await.map_err(|source| Error::GoogleCloudRequest { source })?;

         let response_value = serde_json::to_value(&response).context(GoogleCloudResponseSerializeSnafu)?;
         serde_json::from_value(response_value).context(GoogleCloudResponseDeserializeSnafu)
    }

    async fn list_cached_contents(&self, page_size: Option<i32>, page_token: Option<String>) -> Result<ListCachedContentsResponse, Error> {
         let parent = format!("projects/{}/locations/{}", self.project, self.location);
         let request = google_cloud_aiplatform_v1::model::ListCachedContentsRequest {
             parent,
             page_size: page_size.unwrap_or(10),
             page_token: page_token.unwrap_or_default(),
         };
         let response = self.cache.list_cached_contents(request, None).await.map_err(|source| Error::GoogleCloudRequest { source })?;

         let response_value = serde_json::to_value(&response).context(GoogleCloudResponseSerializeSnafu)?;
         serde_json::from_value(response_value).context(GoogleCloudResponseDeserializeSnafu)
    }

    async fn update_cached_content(&self, name: &str, req: CacheExpirationRequest) -> Result<CachedContent, Error> {
         // This maps to UpdateCachedContentRequest?
         // req contains expiration.
         // We need to construct UpdateCachedContentRequest.
         // And CachedContent object with updated fields.
         // And FieldMask.

         // For now, let's assume  can be serialized into something useful or we build manually.
         //  has  or .

         // Vertex AI  expects  and .
         let mut cached_content = google_cloud_aiplatform_v1::model::CachedContent::default();
         cached_content.name = name.to_string();

         let mut paths = Vec::new();

         if let Some(ttl) = req.ttl {
             // Convert duration string to Duration?
             //  in  is String?
             // Proto expects .
             // This conversion is painful.
             // Let's defer if possible.
             // Or use  string if supported.
             // Actually  models use  for .
             //  in  likely uses String (ISO 8601).

             // If  is set, we set .
             // But  proto has  oneof.

             // For now, I'll return Unsupported for Update if complex conversion is needed, or try simplistic approach.
             // "updateCachedContent"

             return Err(Error::GoogleCloudUnsupported { operation: "updateCachedContent (complex oneof mapping)" });
         }

         // If ...

         Err(Error::GoogleCloudUnsupported { operation: "updateCachedContent" })
    }

    async fn delete_cached_content(&self, name: &str) -> Result<(), Error> {
         let request = google_cloud_aiplatform_v1::model::DeleteCachedContentRequest {
             name: name.to_string(),
         };
         self.cache.delete_cached_content(request, None).await.map_err(|source| Error::GoogleCloudRequest { source })?;
         Ok(())
    }
